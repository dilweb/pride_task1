Цель: превратить твой текущий «линейный конвейер из трёх сервисов» в настоящую event-driven цепочку с:

несколькими шагами обработки,
возможностью отката (компенсацией),
ретраями и DLQ,
идемпотентностью (чтобы дубли не ломали всё).
Всё остальное (масштабирование, стейт-стор и т.д.) пока убираем — добавим потом, если захочешь.

Что будет происходить с заказом?
Клиент отправляет заказ → публикуется событие order.created
Сервис «Инвентарь» пытается зарезервировать товар:если ок → inventory.reserved
если нет товара → inventory.reserve-failed
Если зарезервировали → сервис «Оплата» пытается списать деньги:ок → payment.succeeded
нет → payment.failed
Если любой шаг упал → запускаются компенсирующие действия:если уже зарезервировали товар → отменяем резерв (inventory.reservation-cancelled)
если уже списали деньги → возвращаем их (payment.refunded)
В конце всегда приходит финальное событие order.completed или order.cancelled
Вот и всё. Никаких 10 топиков и 7 сервисов — максимум 4–5 сервисов и 3–4 топика.

Сервисы:
Order API (FastAPI) — тот же, что у тебя сейчас POST /orders → генерирует order_id и saga_id (один UUID на всю сагу) → публикует событие в топик order.events:
{

  "event_type": "order.created",

  "order_id": "...",

  "saga_id": "...",

  "message_id": uuid(),

  "payload": {

    "user_id": null,

    "items": [],

    "amount": 999

  }

}

Orchestrator (новый сервис — мозг всей саги) Подписывается на топик order.events По состоянию заказа (хранит в памяти или в простом dict) решает, что делать дальше:увидел order.created → шлёт команду reserve_inventory в топик inventory.commands
увидел inventory.reserved → шлёт charge_payment в payment.commands
увидел любой *failed → шлёт компенсирующие команды и в конце order.cancelled
всё ок → order.completed
Inventory Service (заглушка, вероятность успеха 80 %) Читает inventory.commands, пытается зарезервировать → публикует в order.events либо inventory.reserved, либо inventory.reserve-failed Если пришла команда отмены → публикует inventory.reservation-cancelled
Payment Service (заглушка, вероятность успеха 70 %) Аналогично: payment.succeeded / payment.failed и компенсация payment.refunded
Notification / Logger (твой старый notifier) Просто подписывается на order.events и красиво логирует финальные события и компенсации.
Топики (всего три, всё с key = order_id)
order.events — 8 партиций (основной changelog, сюда летят ВСЕ события саги)
inventory.commands — 4 партиции
payment.commands — 4 партиции
(опционально) retry.events и dlq — добавишь потом
Две главные фишки, которые ты сразу почувствуешь
Идемпотентность Каждое событие имеет message_id (UUID). Все consumers проверяют: уже видели этот message_id? → просто ack и ничего не делаем. Это спасает от дубликатов при ретраях.
Ретраи (очень простая версия) В orchestrator е при любом *.failed не сразу отменяем, а ждём 5 тирэ 10 сек и пробуем весь неудачный шаг заново (макс 3 попытки). После третьего фейла — компенсация и отмена.
Что должно работать на приёмке
Happy path: заказ → резерв → оплата → completed (в логах должно быть видно всю цепочку)
Fail на инвентаре → сразу отмена, ничего не списывается
Fail на оплате → отмена резерва товара + (если захочешь) возврат денег
Ретраи: заставь Payment падать два раза → на третий успех → заказ прошёл
Всё. Это уже настоящая event-driven сага, которую реально используют в 90% компаний на Kafka, но без перегруза.

Если сделаешь эту версию — дальше уже легко добавить DLQ, стейт-стор через Kafka Streams, трассировку и тд и тп.

